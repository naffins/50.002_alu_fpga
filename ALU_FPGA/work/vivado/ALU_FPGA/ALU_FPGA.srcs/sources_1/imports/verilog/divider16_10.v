/*
   This file was generated automatically by Alchitry Labs version 1.2.1.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module divider16_10 (
    input [15:0] a,
    input [15:0] b,
    output reg [15:0] div
  );
  
  
  
  wire [(5'h10+0)-1:0] M_a_processed_out;
  reg [(5'h10+0)-1:0] M_a_processed_inp0;
  reg [(5'h10+0)-1:0] M_a_processed_inp1;
  reg [(5'h10+0)-1:0] M_a_processed_s0;
  
  genvar GEN_a_processed0;
  generate
  for (GEN_a_processed0=0;GEN_a_processed0<5'h10;GEN_a_processed0=GEN_a_processed0+1) begin: a_processed_gen_0
    mux2_5 a_processed (
      .inp0(M_a_processed_inp0[GEN_a_processed0*(1)+(1)-1-:(1)]),
      .inp1(M_a_processed_inp1[GEN_a_processed0*(1)+(1)-1-:(1)]),
      .s0(M_a_processed_s0[GEN_a_processed0*(1)+(1)-1-:(1)]),
      .out(M_a_processed_out[GEN_a_processed0*(1)+(1)-1-:(1)])
    );
  end
  endgenerate
  
  wire [(5'h10+0)-1:0] M_b_processed_out;
  reg [(5'h10+0)-1:0] M_b_processed_inp0;
  reg [(5'h10+0)-1:0] M_b_processed_inp1;
  reg [(5'h10+0)-1:0] M_b_processed_s0;
  
  genvar GEN_b_processed0;
  generate
  for (GEN_b_processed0=0;GEN_b_processed0<5'h10;GEN_b_processed0=GEN_b_processed0+1) begin: b_processed_gen_0
    mux2_5 b_processed (
      .inp0(M_b_processed_inp0[GEN_b_processed0*(1)+(1)-1-:(1)]),
      .inp1(M_b_processed_inp1[GEN_b_processed0*(1)+(1)-1-:(1)]),
      .s0(M_b_processed_s0[GEN_b_processed0*(1)+(1)-1-:(1)]),
      .out(M_b_processed_out[GEN_b_processed0*(1)+(1)-1-:(1)])
    );
  end
  endgenerate
  
  wire [(5'h10+0)-1:0] M_out_process_out;
  reg [(5'h10+0)-1:0] M_out_process_inp0;
  reg [(5'h10+0)-1:0] M_out_process_inp1;
  reg [(5'h10+0)-1:0] M_out_process_s0;
  
  genvar GEN_out_process0;
  generate
  for (GEN_out_process0=0;GEN_out_process0<5'h10;GEN_out_process0=GEN_out_process0+1) begin: out_process_gen_0
    mux2_5 out_process (
      .inp0(M_out_process_inp0[GEN_out_process0*(1)+(1)-1-:(1)]),
      .inp1(M_out_process_inp1[GEN_out_process0*(1)+(1)-1-:(1)]),
      .s0(M_out_process_s0[GEN_out_process0*(1)+(1)-1-:(1)]),
      .out(M_out_process_out[GEN_out_process0*(1)+(1)-1-:(1)])
    );
  end
  endgenerate
  
  wire [(2'h3+0)*16-1:0] M_tc_out;
  reg [(2'h3+0)*16-1:0] M_tc_inp;
  
  genvar GEN_tc0;
  generate
  for (GEN_tc0=0;GEN_tc0<2'h3;GEN_tc0=GEN_tc0+1) begin: tc_gen_0
    two_compliment16_18 tc (
      .inp(M_tc_inp[GEN_tc0*(5'h10)+(5'h10)-1-:(5'h10)]),
      .out(M_tc_out[GEN_tc0*(5'h10)+(5'h10)-1-:(5'h10)])
    );
  end
  endgenerate
  
  reg [15:0] unsigned_div;
  
  always @* begin
    M_tc_inp[0+15-:16] = a;
    M_a_processed_s0 = {5'h10{a[15+0-:1]}};
    M_a_processed_inp0 = a;
    M_a_processed_inp1 = M_tc_out[0+15-:16];
    M_tc_inp[16+15-:16] = b;
    M_b_processed_s0 = {5'h10{b[15+0-:1]}};
    M_b_processed_inp0 = b;
    M_b_processed_inp1 = M_tc_out[16+15-:16];
    unsigned_div = M_a_processed_out / M_b_processed_out;
    M_tc_inp[32+15-:16] = unsigned_div;
    M_out_process_s0 = {5'h10{a[15+0-:1] ^ b[15+0-:1]}};
    M_out_process_inp0 = unsigned_div;
    M_out_process_inp1 = M_tc_out[32+15-:16];
    div = M_out_process_out;
  end
endmodule
